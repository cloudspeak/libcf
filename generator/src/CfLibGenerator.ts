import * as fs from 'fs'
import * as path from 'path';
import { CfDefinitions } from './CloudFormationDefinitionTypes'
import { FileUtils } from './FileUtils';
import { CloudFormationUtils } from './CloudFormationUtils'
import { ResourceType } from './ResourceType'
import { NamespaceNode } from './NamespaceNode'
import { RootNode } from './RootNode';
import { PropertyType } from './PropertyType';
import { TsGenerator } from './TsGenerator';
import { OrphanedPropertyType } from './OrphanedPropertyType';

module.exports = class Generator {

    fileUtils: FileUtils
    outputFile: string
    data: CfDefinitions

    constructor(outputFile: string) {
        this.fileUtils = new FileUtils()
        this.outputFile = outputFile;
    }

    generate(filename: string) {

        this.data = CloudFormationUtils.loadSpec(filename)
        
        let cfNamespaceTreeRoot = this.createExportsTreeWithResourceTypes()

        let exportsTreeRoot = new NamespaceNode(TsGenerator.CfNamespaceName)
        exportsTreeRoot.set(TsGenerator.CfNamespaceName, cfNamespaceTreeRoot)

        let orphanProperties = this.addPropertyTypesToExportTree(cfNamespaceTreeRoot)
        exportsTreeRoot.orphanedProperties = this.generateOrphanPropertyTypes(orphanProperties)

        let codeLines = [ 
            `import { ${TsGenerator.CfResourceInterface} as ${TsGenerator.CfResourceInterfaceAlias} } from "./${TsGenerator.CfResourceInterface}";`,
            '// *************************************************************************',
            '// This file was generated by cloudspeak-libcf-generator.  Do not modify',
            '// *************************************************************************',
            ...exportsTreeRoot.generateCode()
        ]
        let fileContent = codeLines.join('\n')
        this.fileUtils.createFolderTree(path.parse(this.outputFile).dir)
        fs.writeFileSync(this.outputFile, fileContent)
    }

    createExportsTreeWithResourceTypes(): RootNode {

        let root = new RootNode()

        for (let resourceTypeName in this.data.ResourceTypes) {
            let resourceTypeData = this.data.ResourceTypes[resourceTypeName]
            let parsedName = CloudFormationUtils.parseTypeName(resourceTypeName)

            let tree = root
            let namespaceLeaf: NamespaceNode

            for (let namespacePart of parsedName.namespace.slice(0, -1) ) {
                if (!tree.get(namespacePart)) {
                    tree.set(namespacePart, new NamespaceNode(namespacePart))
                }
                namespaceLeaf = tree.get(namespacePart) as NamespaceNode
                tree = tree.get(namespacePart)
            }

            namespaceLeaf.resources.push(new ResourceType(parsedName, resourceTypeData))
        }

        return root
    }

    addPropertyTypesToExportTree(root: RootNode): string[] {
        let orphanProperties: string[] = []

        for (let propertyTypeName in this.data.PropertyTypes) {
            let propertyTypeData = this.data.PropertyTypes[propertyTypeName]
            let parsedName = CloudFormationUtils.parseTypeName(propertyTypeName)


            let tree = root
            let namespaceLeaf: NamespaceNode

            for (let namespacePart of parsedName.namespace.slice(0, -1) ) {
                namespaceLeaf = tree.get(namespacePart) as NamespaceNode
                tree = tree.get(namespacePart)
            }

            if (namespaceLeaf) {
                let propertyType = new PropertyType(parsedName, propertyTypeData)
                namespaceLeaf.addProperty(propertyType)

                let resourceType = namespaceLeaf.resources.find(r => r.parsedName.resourceName === parsedName.resourceName)
                resourceType.addPropertyType(propertyType)
            }
            else {
                orphanProperties.push(propertyTypeName)
            }

            
        }
        return orphanProperties
    }

    
    /**
     * @param {NamespaceNode} exportsTree 
     */
    generateOrphanPropertyTypes(orphanProperties: string[]): OrphanedPropertyType[] {

        let orphanedPropertyTypes: OrphanedPropertyType[] = []

        for (let propertyTypeName of orphanProperties) {
            // For now Tag is the only orphaned property type, lets throw an error if it's not Tag
            if (propertyTypeName === "Tag") {
                let propertyTypeData = this.data.PropertyTypes[propertyTypeName]
                orphanedPropertyTypes.push(new OrphanedPropertyType(propertyTypeName, propertyTypeData))
            }
            else {
                throw new Error("Unknown global property " + propertyTypeName)
            }
        }

        return orphanedPropertyTypes
    }

}