const fs = require('fs');
const path = require('path');
const FileUtils = require('./FileUtils')
const CloudFormationUtils = require('./CloudFormationUtils')
const ResourceTypeNode = require('./ResourceTypeNode')
const OrphanPropertyTypeNode = require('./OrphanPropertyTypeNode')
const NamespaceNode = require('./NamespaceNode')
const PropertyType = require('./PropertyType')

module.exports = class Generator {

    constructor(outputPath) {
        this.fileUtils = new FileUtils()
        this.outputPath = outputPath;
    }
    



    generate(filename) {

        this.data = CloudFormationUtils.loadSpec(filename)
        
        
        let exportsTree = this.createExportsTreeWithResourceTypes(new NamespaceNode())
        let orphanProperties = this.addPropertyTypesToExportTree(exportsTree)
        this.addOrphanedPropertyTypesToExportTree(exportsTree, orphanProperties)

        let codeLines = [ 
            '// @ts-check',
            '// *************************************************************************',
            '// This file was generated by cloudspeak-libcf-generator.  Do not modify',
            '// *************************************************************************',
            ...this.generateExportsCode(exportsTree)
        ]
        let fileContent = codeLines.join('\n')

        let outputFile = path.join(this.outputPath, "cfDefinitions.js")
        this.fileUtils.createFolderTree(this.outputPath)
        fs.writeFileSync(outputFile, fileContent)        
    }

    /**
     * @param {NamespaceNode} exportsTree 
     */
    createExportsTreeWithResourceTypes(exportsTree) {

        for (let resourceTypeName in this.data.ResourceTypes) {
            let resourceTypeData = this.data.ResourceTypes[resourceTypeName]
            let parsedName = CloudFormationUtils.parseTypeName(resourceTypeName)

            let tree = exportsTree

            for (let namespacePart of parsedName.namespace.slice(0, -1) ) {
                if (!tree.get(namespacePart)) tree.set(namespacePart, new NamespaceNode())
                tree = tree.get(namespacePart)
            }

            tree.set(parsedName.namespace[parsedName.namespace.length - 1],
                    new ResourceTypeNode(parsedName, resourceTypeData
            ));
        }

        return exportsTree
    }

    
    /**
     * @param {NamespaceNode} exportsTree 
     */
    addPropertyTypesToExportTree(exportsTree) {
        let orphanProperties = []

        for (let propertyTypeName in this.data.PropertyTypes) {
            let propertyTypeData = this.data.PropertyTypes[propertyTypeName]
            let parsedName = CloudFormationUtils.parseTypeName(propertyTypeName)

            let tree = exportsTree
            for (let namespacePart of parsedName.namespace) {
                tree = tree.get(namespacePart)
            }

            /** @type {ResourceTypeNode} */
            let resourceNamespace = (/** @type {ResourceNamespace} */ tree);
            
            if (resourceNamespace) {
                resourceNamespace.addPropertyType(new PropertyType(parsedName, propertyTypeData))
            }
            else {
                orphanProperties.push(propertyTypeName)
            }
            
        }
        return orphanProperties
    }

    
    /**
     * @param {NamespaceNode} exportsTree 
     */
    addOrphanedPropertyTypesToExportTree(exportsTree, orphanProperties) {

        for (let propertyTypeName of orphanProperties) {
            if (propertyTypeName === "Tag") {
                let propertyTypeData = this.data.PropertyTypes[propertyTypeName]
                let parsedName = {
                    propertyName: propertyTypeName,
                    resourceName: null,
                    namespace: null,
                    fullname: propertyTypeName
                }
                exportsTree.set(propertyTypeName, new OrphanPropertyTypeNode(parsedName, propertyTypeData))
            }
            else {
                throw new Error("Unknown global property " + propertyTypeName)
            }
        }
    }
    /**
     * 
     * @param {NamespaceNode} exportsTree
     * @returns {string[]}
     */
    generateExportsCode(exportsTree) {
        let exportsCode = exportsTree.generateCode("module.exports = ")
        return exportsCode
    }
    

}